<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>TP 4 WebVR - Exercices 1 Ã  4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <!-- BibliothÃ¨ques A-Frame et extensions -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  
  <!-- Suppression du conflit de nom "grabbable" -->
  <script> delete AFRAME.components["grabbable"]; </script>
  
  <!-- aframe-extras (sphere-collider) -->
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
  
  <!-- Physics system (CANNON/Ammo support) -->
  <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>
  
  <!-- super-hands 3.x -->
  <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>
  
  <style>
    html, body {
      margin: 0;
      height: 100%;
      font-family: system-ui;
    }
    a-scene {
      position: fixed;
      inset: 0;
    }
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border-radius: 8px;
      z-index: 1000;
      pointer-events: none;
    }
    .instructions {
      position: fixed;
      left: 12px;
      bottom: 12px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border-radius: 8px;
      z-index: 1000;
      pointer-events: none;
      max-width: 300px;
    }
  </style>
</head>
<body>
  <div class="hud">TP 4 WebVR - Exercices 1 Ã  4</div>
  <div class="instructions">
    ðŸŽ® Gauche: dÃ©placer â€” Droite: tourner<br>
    ðŸ‘Š Main: attraper les objets sur la table<br>
    ðŸ‘‹ Main: pousser les objets (collision physique)
  </div>

  <a-scene
    physics="debug: false; gravity: -9.8;"
    renderer="antialias:true; physicallyCorrectLights:true; colorManagement:true; logarithmicDepthBuffer:true; sortTransparentObjects:true"
    shadow="type: pcfsoft"
    background="color: #87CEEB">

    <!-- Sol avec physique -->
    <a-entity 
      id="ground" 
      static-body
      geometry="primitive:plane;width:40;height:40"
      rotation="-90 0 0" 
      material="color:#7da07d;roughness:1;metalness:0"
      shadow="receive:true">
    </a-entity>

    <!-- Table pour placer les objets Ã  hauteur accessible -->
    <a-entity id="table" position="0 0 -3">
      <!-- Plateau de la table -->
      <a-box 
        id="table-top"
        static-body
        position="0 1.5  0"
        width="3" height="0.05" depth="2"
        material="color:#8B4513;roughness:0.8;metalness:0.2"
        shadow="cast:true;receive:true">
      </a-box>
      
      <!-- Pieds de la table -->
      <a-box 
        static-body
        position="-1.2 0.375 -0.8"
        width="0.1" height="2" depth="0.1"
        material="color:#654321"
        shadow="cast:true">
      </a-box>
      <a-box 
        static-body
        position="1.2 0.375 -0.8"
        width="0.1" height="2" depth="0.1"
        material="color:#654321"
        shadow="cast:true">
      </a-box>
      <a-box 
        static-body
        position="-1.2 0.375 0.8"
        width="0.1" height="2" depth="0.1"
        material="color:#654321"
        shadow="cast:true">
      </a-box>
      <a-box 
        static-body
        position="1.2 0.375 0.8"
        width="0.1" height="2" depth="0.1"
        material="color:#654321"
        shadow="cast:true">
      </a-box>
    </a-entity>

    <!-- Objets sur la table (Exercice 1) -->
    <a-box 
      id="box1"
      position="-0.5 1.55 -2.5" 
      depth="0.3" height="0.3" width="0.3"
      material="color:#c94f4f;roughness:0.8;metalness:0.2"
      dynamic-body="mass: 1; shape: box; linearDamping: 0.5; angularDamping: 0.5"
      shadow="cast:true;receive:true"
      class="pushable-object grabbable"
      grabbable
      touch-highlight>
    </a-box>
    
    <a-sphere 
      id="sphere1"
      position="0.5 1.55 -2.5" 
      radius="0.15"
      material="color:#4f79c9;roughness:0.6;metalness:0.2"
      dynamic-body="mass: 1; shape: sphere; linearDamping: 0.5; angularDamping: 0.5"
      shadow="cast:true;receive:true"
      class="pushable-object grabbable"
      grabbable
      touch-highlight>
    </a-sphere>
    
    <a-cylinder 
      id="cylinder1"
      position="0 1.55 -3" 
      radius="0.15" height="0.3"
      material="color:#4fc94f;roughness:0.7;metalness:0.2"
      dynamic-body="mass: 1; shape: cylinder; linearDamping: 0.5; angularDamping: 0.5"
      shadow="cast:true;receive:true"
      class="pushable-object grabbable"
      grabbable
      touch-highlight>
    </a-cylinder>

    <!-- Gun  -->
<a-box 
  id="gun"
  gltf-model="/heavy_plasma_gun_kurtz_x1.glb" 
  scale="0.3 0.3 0.3"       
  rotation="180 90 -90"         
  position="1 1.55 -2.5"
  dynamic-body="mass: 1; shape: box;"
  shadow="cast:true;receive:true"
  class="grabbable"
  grabbable
  gun-shoot>

  <!-- PoignÃ©e pour la main -->
  <a-entity id="grip-point" position="0 -0.05 0.2" rotation="0 0 0"></a-entity>
</a-box>

<a-assets>
  <audio id="hit-sound" src="PistolShot01.mp3"></audio>
</a-assets>

<!-- EntitÃ©s audio globales -->
<a-entity id="hit-audio" sound="src: #hit-sound"></a-entity>


  <!-- Targets-->
  <a-entity red-sphere-spawn-on-button="area: 40 3 40"></a-entity>



    <!-- LumiÃ¨res (Exercice 1) -->
    <a-entity light="type:ambient;intensity:0.35;color:#fff"></a-entity>
    <a-entity 
      id="sun"
      light="type:directional;intensity:1;castShadow:true;shadowBias:-0.0003"
      position="5 8 3" 
      rotation="-45 30 0">
    </a-entity>

    <!-- Ciel -->
    <a-sky color="#87CEEB"></a-sky>

    <!-- Rig + camÃ©ra + contrÃ´leurs SIMPLIFIÃ‰S -->
    <a-entity id="rig" position="0 1.6 0" rotation="0 0 0">
      <a-entity id="pitch" rotation="0 0 0">
        <a-entity id="head" camera look-controls="pointerLockEnabled: true"></a-entity>
        
        <!-- ContrÃ´leurs VR -->
        <a-entity 
          id="left-hand" 
          hand-controls="hand: left; handModelStyle: lowPoly; color: #ff0000"
          super-hands="colliderEvent: collidestart; colliderEndEvent: collideend;"
          sphere-collider="objects: .grabbable; radius: 0.05"
          left-stick-move="speed:3"
          grab-handler
          event-set__grabstart="_event: gripdown; attribute: class; value: grabbing"
          event-set__grabend="_event: gripup; attribute: class; value:">
          <!-- Collider pour la main -->
          <a-sphere 
            class="collider" 
            radius="0.05" 
            visible="false" 
            position="0 0 0">
          </a-sphere>
        </a-entity>
        
        <a-entity 
          id="right-hand" 
          hand-controls="hand: right; handModelStyle: lowPoly; color: #0000ff"
          super-hands="colliderEvent: collidestart; colliderEndEvent: collideend;"
          sphere-collider="objects: .grabbable; radius: 0.05"
          right-stick-turn="turnSpeed:120; deadzone:0.08"
          grab-handler
          event-set__grabstart="_event: gripdown; attribute: class; value: grabbing"
          event-set__grabend="_event: gripup; attribute: class; value:">
          <!-- Collider pour la main -->
          <a-sphere 
            class="collider" 
            radius="0.05" 
            visible="false" 
            position="0 0 0">
          </a-sphere>
        </a-entity> 
      </a-entity>
    </a-entity>

    
    <!-- WebXR -->
    <a-entity webxr="optionalFeatures: local-floor, bounded-floor"></a-entity>

    <!-- Scripts de composants personnalisÃ©s CORRIGÃ‰S -->
    <script>
  // Composant pour dÃ©tecter le toucher et changer la couleur
  AFRAME.registerComponent('touch-highlight', {
    init: function () {
      this.originalColor = this.el.getAttribute('material').color;
      this.isTouched = false;
      
    this.el.addEventListener('hover-start', () => this.highlight());
    this.el.addEventListener('hover-end', () => this.unhighlight());

    },
    
    highlight: function () {
      if (!this.isTouched) {
        this.isTouched = true;
        this.el.setAttribute('material', 'color', '#FFFF00');
        console.log('Objet touchÃ©:', this.el.id);
        
        setTimeout(() => {
          this.unhighlight();
        }, 1000);
      }
    },
    
    unhighlight: function () {
      this.isTouched = false;
      this.el.setAttribute('material', 'color', this.originalColor);
    }
  });

  // Composant pour le mouvement avec le joystick gauche
  AFRAME.registerComponent('left-stick-move', {
    schema: { 
      speed: {type:'number', default:3}, 
      deadzone:{type:'number', default:0.05} 
    },
    init() {
      this.axis = {x:0,y:0};
      this.rig  = document.querySelector('#rig');
      this.cam  = document.querySelector('#head');
      this.el.addEventListener('axismove', e => { 
        this.axis = this.readStickAxes(e.detail.axis); 
      });
    },
    readStickAxes(axis){
      const ax = axis || [];
      let x = ax[0] ?? 0, y = ax[1] ?? 0;
      if (Math.abs(x) < 0.001 && Math.abs(y) < 0.001 && ax.length >= 4) {
        x = ax[2] ?? 0; 
        y = ax[3] ?? 0;
      }
      return {x, y};
    },
    tick(t,dt){
      if(!this.rig || !this.cam) return;
      const s = this.data.speed * (dt/1000);
      let {x,y} = this.axis;
      if (Math.hypot(x,y) < this.data.deadzone) return;

      const yaw = (this.rig.getAttribute('rotation')?.y || 0) + (this.cam.getAttribute('rotation')?.y || 0);
      const rad = THREE.MathUtils.degToRad(yaw);
      const forward = new THREE.Vector3(-Math.sin(rad), 0, -Math.cos(rad));
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

      this.rig.object3D.position
        .addScaledVector(forward, -y*s)
        .addScaledVector(right, -x*s);
    }
  });

  // Composant pour la rotation avec le joystick droit
  AFRAME.registerComponent('right-stick-turn', {
    schema:{ 
      turnSpeed:{type:'number',default:120}, 
      deadzone:{type:'number',default:0.08},
      enablePitch: {type: 'boolean', default: false}
    },
    init(){
      this.x=0; this.y=0;
      this.rig   = document.querySelector('#rig');
      this.pitch = document.querySelector('#pitch');
      this.el.addEventListener('axismove', e => {
        const a = this.readStickAxes(e.detail.axis);
        this.x = a.x; this.y = a.y;
      });
      
      this.isVR = false;
      this.el.sceneEl.addEventListener('enter-vr', () => { this.isVR = true; });
      this.el.sceneEl.addEventListener('exit-vr', () => { this.isVR = false; });
    },
    readStickAxes(axis){
      const ax = axis || [];
      let x = ax[0] ?? 0, y = ax[1] ?? 0;
      if (Math.abs(x) < 0.001 && Math.abs(y) < 0.001 && ax.length >= 4) {
        x = ax[2] ?? 0; 
        y = ax[3] ?? 0;
      }
      return {x, y};
    },
    tick(t,dt){
      if(!this.rig || !this.pitch) return;
      const s = this.data.turnSpeed * (dt/1000);

      if (Math.abs(this.x) >= this.data.deadzone) {
        const rot = this.rig.getAttribute('rotation') || {x:0,y:0,z:0};
        rot.y -= this.x * s;
        this.rig.setAttribute('rotation', rot);
      }

      if (!this.isVR && Math.abs(this.y) >= this.data.deadzone) {
        const pr = this.pitch.getAttribute('rotation') || {x:0,y:0,z:0};
        pr.x = this.clamp(pr.x + (-this.y * s), -80, 80);
        pr.z = 0;
        this.pitch.setAttribute('rotation', pr);
      }
    },
    clamp(v,a,b){ 
      return Math.max(a, Math.min(b, v)); 
    }
  });

  // Composant pour le grab simplifiÃ© et fonctionnel
AFRAME.registerComponent('grab-handler', {
  init() {
    this.grabbedObject = null;

    this.el.addEventListener('gripdown', () => this.tryGrab());
    this.el.addEventListener('gripup', () => this.release());

    // Relier trigger index au tir
    this.el.addEventListener('triggerdown', () => {
      if (this.grabbedObject && this.grabbedObject.components['gun-shoot']) {
        this.grabbedObject.components['gun-shoot'].shoot();
      }
    });
  },

  tryGrab() {
    if (this.grabbedObject) return;
    const objects = document.querySelectorAll('.grabbable');
    let closestObject = null;
    let closestDistance = 0.5;

    const handPos = new THREE.Vector3();
    this.el.object3D.getWorldPosition(handPos);

    objects.forEach(obj => {
      const objPos = new THREE.Vector3();
      obj.object3D.getWorldPosition(objPos);
      const distance = handPos.distanceTo(objPos);

      if (distance < closestDistance) {
        closestDistance = distance;
        closestObject = obj;
      }
    });

    if (closestObject) {
      this.grabObject(closestObject);
    }
  },

  grabObject(obj) {
    this.grabbedObject = obj;
    obj.removeAttribute('dynamic-body');

    // VÃ©rifier si lâ€™objet a un grip-point
    const grip = obj.querySelector('#grip-point');
    if (grip) {
      // RÃ©cupÃ©rer la transformation monde du grip
      const gripWorldPos = new THREE.Vector3();
      const gripWorldQuat = new THREE.Quaternion();
      grip.object3D.getWorldPosition(gripWorldPos);
      grip.object3D.getWorldQuaternion(gripWorldQuat);

      // Placer lâ€™arme dans la main
      this.el.object3D.attach(obj.object3D);

      // Aligner lâ€™arme selon le grip
      obj.object3D.position.set(0, 0, 0);
      obj.object3D.quaternion.copy(gripWorldQuat);
    } else {
      // Si pas de grip, comportement normal
      this.el.object3D.attach(obj.object3D);
    }

    console.log('Objet attrapÃ©:', obj.id);
  },


  release() {
    if (!this.grabbedObject) return;
    const obj = this.grabbedObject;
    this.el.sceneEl.object3D.attach(obj.object3D);
    obj.setAttribute('dynamic-body', 'mass: 1; shape: auto;');
    this.grabbedObject = null;
  }
});

// Composant arme
AFRAME.registerComponent('gun-shoot', {
  shoot: function () {
    const scene = this.el.sceneEl;
    const bullet = document.createElement('a-sphere');

    // RÃ©cupÃ¨re position et direction
    const gunWorldPos = new THREE.Vector3();
    const gunWorldDir = new THREE.Vector3();
    this.el.object3D.getWorldPosition(gunWorldPos);
    this.el.object3D.getWorldDirection(gunWorldDir);

    // ðŸ”„ Inverser la direction (Z -> -Z)
    gunWorldDir.negate();

    // DÃ©place lÃ©gÃ¨rement le point de spawn vers l'avant
    const spawnPos = gunWorldPos.clone().add(gunWorldDir.clone().multiplyScalar(0.5));

    bullet.classList.add('bullet');
    bullet.setAttribute('radius', 0.05);
    bullet.setAttribute('color', 'yellow');
    bullet.setAttribute('position', spawnPos);
    bullet.setAttribute(
      'dynamic-body',
      'mass:0.1; shape:sphere; linearDamping:0; angularDamping:0;'
    );
    scene.appendChild(bullet);

    // Appliquer l'impulsion aprÃ¨s initialisation
    bullet.addEventListener('body-loaded', () => {
      setTimeout(() => {
        if (!bullet.body) return;

        // âš ï¸ recalcul de la direction et inversion pour cohÃ©rence
        this.el.object3D.getWorldDirection(gunWorldDir);
        gunWorldDir.negate();

        const impulse = new CANNON.Vec3(
          gunWorldDir.x * 2,
          gunWorldDir.y * 2,
          gunWorldDir.z * 2
        );
        const worldPoint = new CANNON.Vec3(
          bullet.body.position.x,
          bullet.body.position.y,
          bullet.body.position.z
        );
        bullet.body.applyImpulse(impulse, worldPoint);
      }, 0);
    });

    // Supprimer la balle aprÃ¨s 3s
    setTimeout(() => {
      if (bullet.parentNode) bullet.parentNode.removeChild(bullet);
    }, 3000);
  }
});

// Composant pour spawn UNE sphÃ¨re rouge Ã  une position alÃ©atoire
// Composant pour les sphÃ¨res rouges qui deviennent vertes quand elles sont touchÃ©es
AFRAME.registerComponent('red-target', {
  init: function () {
    const el = this.el;

    el.addEventListener('collide', (e) => {
      const other = e.detail.body.el;
      if (other && other.classList.contains('bullet')) {

        // ðŸ”Š Joue le son de hit
        const hitSound = el.sceneEl.querySelector('#hit-audio');
        if (hitSound && hitSound.components.sound) {
          hitSound.components.sound.stopSound();
          hitSound.components.sound.playSound();
        }

        el.setAttribute('color', '#00ff00');
        setTimeout(() => {
          if (el.parentNode) el.parentNode.removeChild(el);
        }, 200);
      }
    });
  }
});


// Composant pour spawn sphÃ¨re rouge sur B/Y
AFRAME.registerComponent('red-sphere-spawn-on-button', {
  schema: {
    area:  { type: 'vec3', default: {x: 40, y: 3, z: 40} }
  },
  init: function () {
    const scene = this.el.sceneEl;

    const spawnSphere = () => {
      const sphere = document.createElement('a-sphere');

      const x = (Math.random() - 0.5) * this.data.area.x;
      const y = Math.random() * this.data.area.y;
      const z = (Math.random() - 0.5) * this.data.area.z;

      sphere.setAttribute('position', { x, y, z });
      sphere.setAttribute('radius', 0.15);
      sphere.setAttribute('color', '#ff0000');
      sphere.setAttribute('material', 'roughness:0.6;metalness:0.2');
      sphere.setAttribute('static-body', 'shape: sphere;'); // collision statique
      sphere.setAttribute('red-target', ''); // permet la rÃ©action au tir

      scene.appendChild(sphere);
    };

    window.addEventListener('bbuttondown', spawnSphere);
    window.addEventListener('ybuttondown', spawnSphere);
  }
});

</script>
  </a-scene>
</body>
</html>