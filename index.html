<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>SceneVR ‚Äì Three.js avec WebXR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/XRControllerModelFactory.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: system-ui;
    }
    
    canvas {
      display: block;
    }
    
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      padding: 8px 12px;
      background: #0008;
      color: #fff;
      border-radius: 8px;
      z-index: 100;
      pointer-events: none;
    }
    
    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 14px;
      z-index: 1000;
    }
    
    #instructions {
      text-align: center;
      background: #0008;
      padding: 20px;
      border-radius: 8px;
    }
    
    #vrButton {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="hud">üéÆ ZQSD: d√©placer ‚Äî Souris: regarder ‚Äî Clic: activer</div>
  <div id="blocker">
    <div id="instructions">
      Cliquez pour jouer<br/>
      ZQSD pour se d√©placer, souris pour regarder<br/>
      Ou utilisez le bouton VR pour la r√©alit√© virtuelle
    </div>
  </div>

  <script>
    // Variables globales
    let scene, camera, renderer, controls;
    let rig, head, pitchObject;
    let gamepads = {};
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = false;
    let prevTime = performance.now();
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    
    // Variables VR
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;
    let isVRSession = false;
    let currentSession = null;

    // Constantes
    const moveSpeed = 5;
    const turnSpeed = 2;

    // Initialisation
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x88ccff);
      scene.fog = new THREE.Fog(0x88ccff, 0, 50);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      
      // Structure pour le mode desktop
      rig = new THREE.Group();
      pitchObject = new THREE.Group();
      head = new THREE.Group();
      
      pitchObject.add(head);
      head.add(camera);
      rig.add(pitchObject);
      scene.add(rig);
      
      // Position initiale
      rig.position.set(0, 1.6, 5);
      camera.position.set(0, 0, 0);

      // Rendu
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Bouton VR
      document.body.appendChild(VRButton.createButton(renderer));

      // Contr√¥les souris (desktop seulement)
      controls = new THREE.PointerLockControls(camera, document.body);
      
      const blocker = document.getElementById('blocker');
      const instructions = document.getElementById('instructions');
      
      instructions.addEventListener('click', function() {
        if (!isVRSession) {
          controls.lock();
        }
      });
      
      controls.addEventListener('lock', function() {
        instructions.style.display = 'none';
        blocker.style.display = 'none';
      });
      
      controls.addEventListener('unlock', function() {
        if (!isVRSession) {
          blocker.style.display = 'block';
          instructions.style.display = '';
        }
      });

      // √âclairage
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 8, 3);
      directionalLight.castShadow = true;
      directionalLight.shadow.bias = -0.0003;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Sol
      const groundGeometry = new THREE.PlaneGeometry(40, 40);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7da07d });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Objets
      const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
      const boxMaterial = new THREE.MeshLambertMaterial({ color: 0xc94f4f });
      const box = new THREE.Mesh(boxGeometry, boxMaterial);
      box.position.set(-1, 0.5, -3);
      box.castShadow = true;
      box.receiveShadow = true;
      scene.add(box);

      const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
      const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x4f79c9 });
      const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      sphere.position.set(1, 1, -2.5);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      scene.add(sphere);

      // Setup WebXR
      setupXR();

      // √âv√©nements
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);
      
      window.addEventListener("gamepadconnected", (e) => {
        console.log("Manette connect√©e:", e.gamepad.id);
        gamepads[e.gamepad.index] = e.gamepad;
      });
      
      window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Manette d√©connect√©e:", e.gamepad.id);
        delete gamepads[e.gamepad.index];
      });

      window.addEventListener('resize', onWindowResize, false);
    }

    // Configuration WebXR
    function setupXR() {
      const controllerModelFactory = new THREE.XRControllerModelFactory();

      // Contr√¥leur gauche
      controller1 = renderer.xr.getController(0);
      controller1.addEventListener('selectstart', onSelectStart);
      controller1.addEventListener('selectend', onSelectEnd);
      scene.add(controller1);

      controllerGrip1 = renderer.xr.getControllerGrip(0);
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);

      // Contr√¥leur droit
      controller2 = renderer.xr.getController(1);
      controller2.addEventListener('selectstart', onSelectStart);
      controller2.addEventListener('selectend', onSelectEnd);
      scene.add(controller2);

      controllerGrip2 = renderer.xr.getControllerGrip(1);
      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      scene.add(controllerGrip2);

      // √âv√©nements session VR
      renderer.xr.addEventListener('sessionstart', () => {
        console.log('Session VR d√©marr√©e');
        isVRSession = true;
        document.getElementById('blocker').style.display = 'none';
        controls.unlock(); // D√©sactiver les contr√¥les souris en VR
      });

      renderer.xr.addEventListener('sessionend', () => {
        console.log('Session VR termin√©e');
        isVRSession = false;
        if (!controls.isLocked) {
          document.getElementById('blocker').style.display = 'flex';
        }
      });
    }

    function onSelectStart(event) {
      const controller = event.target;
      // Ajouter des effets visuels quand on appuie sur le bouton
      console.log('Bouton press√© sur contr√¥leur');
    }

    function onSelectEnd(event) {
      const controller = event.target;
      // Retirer les effets visuels
      console.log('Bouton rel√¢ch√© sur contr√¥leur');
    }

    // Contr√¥les clavier
    function onKeyDown(event) {
      if (isVRSession) return; // Ignorer en VR
        
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
        case 'KeyZ': // AZERTY
          moveForward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
        case 'KeyQ': // AZERTY
          moveLeft = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = true;
          break;
        case 'Space':
          if (canJump === true) velocity.y += 350;
          canJump = false;
          break;
      }
    }

    function onKeyUp(event) {
      if (isVRSession) return; // Ignorer en VR
        
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
        case 'KeyZ': // AZERTY
          moveForward = false;
          break;
        case 'ArrowLeft':
        case 'KeyA':
        case 'KeyQ': // AZERTY
          moveLeft = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = false;
          break;
      }
    }

    // Contr√¥les manette (pour VR et desktop)
    function updateGamepads() {
      const gamepadList = navigator.getGamepads ? navigator.getGamepads() : [];
      
      for (let i = 0; i < gamepadList.length; i++) {
        const gamepad = gamepadList[i];
        if (!gamepad) continue;
        
        gamepads[gamepad.index] = gamepad;
        
        // Stick gauche - D√©placement
        const leftStick = readStickAxes(gamepad.axes.slice(0, 2));
        const rightStick = readStickAxes(gamepad.axes.slice(2, 4));
        
        if (isVRSession) {
          // En VR: stick gauche pour le d√©placement
          if (Math.hypot(leftStick.x, leftStick.y) > 0.1) {
            moveForward = leftStick.y < -0.1;
            moveBackward = leftStick.y > 0.1;
            moveLeft = leftStick.x < -0.1;
            moveRight = leftStick.x > 0.1;
          } else {
            moveForward = moveBackward = moveLeft = moveRight = false;
          }
          
          // Stick droit pour la rotation en VR
          if (Math.abs(rightStick.x) > 0.1) {
            // Rotation snap (comme dans la plupart des jeux VR)
            rig.rotation.y -= rightStick.x * 0.05 * turnSpeed;
          }
        } else {
          // En desktop
          if (Math.hypot(leftStick.x, leftStick.y) > 0.1) {
            moveForward = leftStick.y < -0.1;
            moveBackward = leftStick.y > 0.1;
            moveLeft = leftStick.x < -0.1;
            moveRight = leftStick.x > 0.1;
          } else if (!isKeyPressed()) {
            moveForward = moveBackward = moveLeft = moveRight = false;
          }
          
          if (Math.abs(rightStick.x) > 0.1) {
            rig.rotation.y -= rightStick.x * 0.05 * turnSpeed;
          }
          
          if (Math.abs(rightStick.y) > 0.1 && !controls.isLocked) {
            pitchObject.rotation.x = THREE.MathUtils.clamp(
              pitchObject.rotation.x + rightStick.y * 0.05 * turnSpeed, 
              -Math.PI/3, 
              Math.PI/3
            );
          }
        }
      }
    }
    
    function readStickAxes(axes) {
      return { x: axes[0] || 0, y: axes[1] || 0 };
    }
    
    function isKeyPressed() {
      return moveForward || moveBackward || moveLeft || moveRight;
    }

    // Mouvement
    function updateMovement(delta) {
      const actualMoveSpeed = moveSpeed * delta;
      
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      velocity.y -= 9.8 * 100.0 * delta;

      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();

      if (moveForward || moveBackward) velocity.z -= direction.z * actualMoveSpeed;
      if (moveLeft || moveRight) velocity.x -= direction.x * actualMoveSpeed;

      // Appliquer le mouvement dans la direction du regard
      let yaw;
      if (isVRSession) {
        // En VR, utiliser la rotation de la cam√©ra directement
        yaw = camera.rotation.y;
      } else {
        // En desktop, utiliser la rotation du rig
        yaw = rig.rotation.y;
      }
      
      const moveX = velocity.x * Math.cos(yaw) - velocity.z * Math.sin(yaw);
      const moveZ = velocity.x * Math.sin(yaw) + velocity.z * Math.cos(yaw);
      
      rig.position.x += moveX * delta;
      rig.position.z += moveZ * delta;
      
      // Garder le joueur au sol
      if (rig.position.y < 1.6) {
        velocity.y = 0;
        rig.position.y = 1.6;
        canJump = true;
      }
    }

    // Animation
    function animate() {
      requestAnimationFrame(animate);
      
      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      
      updateGamepads();
      
      if (!isVRSession && controls.isLocked) {
        updateMovement(delta);
      } else if (isVRSession) {
        // Toujours mettre √† jour le mouvement en VR
        updateMovement(delta);
      }
      
      renderer.render(scene, camera);
      prevTime = time;
    }

    // Redimensionnement
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // D√©marrer
    init();
    animate();
  </script>
</body>
</html>