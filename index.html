<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>SceneVR ‚Äì Three.js Version</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/stats.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: system-ui;
    }
    
    canvas {
      display: block;
    }
    
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      padding: 8px 12px;
      background: #0008;
      color: #fff;
      border-radius: 8px;
      z-index: 100;
      pointer-events: none;
    }
    
    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 14px;
      z-index: 1000;
    }
    
    #instructions {
      text-align: center;
      background: #0008;
      padding: 20px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <div class="hud">üéÆ ZQSD: d√©placer ‚Äî Souris: regarder ‚Äî Clic: activer</div>
  <div id="blocker">
    <div id="instructions">
      Cliquez pour jouer<br/>
      ZQSD pour se d√©placer, souris pour regarder
    </div>
  </div>

  <script>
    // Variables globales
    let scene, camera, renderer, controls;
    let rig, head, pitchObject;
    let gamepads = {};
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = false;
    let prevTime = performance.now();
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();

    // Constantes
    const moveSpeed = 5;
    const turnSpeed = 2;

    // Initialisation
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x88ccff);
      scene.fog = new THREE.Fog(0x88ccff, 0, 50);

      // Camera et rig
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      
      // Structure rig -> pitch -> head (camera)
      rig = new THREE.Group();
      pitchObject = new THREE.Group();
      head = new THREE.Group();
      
      pitchObject.add(head);
      head.add(camera);
      rig.add(pitchObject);
      scene.add(rig);
      
      // Position initiale
      rig.position.set(0, 1.6, 5);
      camera.position.set(0, 0, 0);

      // Rendu
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Contr√¥les souris
      controls = new THREE.PointerLockControls(camera, document.body);
      
      const blocker = document.getElementById('blocker');
      const instructions = document.getElementById('instructions');
      
      instructions.addEventListener('click', function() {
        controls.lock();
      });
      
      controls.addEventListener('lock', function() {
        instructions.style.display = 'none';
        blocker.style.display = 'none';
      });
      
      controls.addEventListener('unlock', function() {
        blocker.style.display = 'block';
        instructions.style.display = '';
      });

      // √âclairage
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 8, 3);
      directionalLight.castShadow = true;
      directionalLight.shadow.bias = -0.0003;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Sol
      const groundGeometry = new THREE.PlaneGeometry(40, 40);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7da07d });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Objets
      const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
      const boxMaterial = new THREE.MeshLambertMaterial({ color: 0xc94f4f });
      const box = new THREE.Mesh(boxGeometry, boxMaterial);
      box.position.set(-1, 0.5, -3);
      box.castShadow = true;
      box.receiveShadow = true;
      scene.add(box);

      const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
      const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x4f79c9 });
      const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      sphere.position.set(1, 1, -2.5);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      scene.add(sphere);

      // √âv√©nements clavier
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);
      
      // √âv√©nements manettes
      window.addEventListener("gamepadconnected", (e) => {
        console.log("Manette connect√©e:", e.gamepad.id);
        gamepads[e.gamepad.index] = e.gamepad;
      });
      
      window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Manette d√©connect√©e:", e.gamepad.id);
        delete gamepads[e.gamepad.index];
      });

      // Redimensionnement
      window.addEventListener('resize', onWindowResize, false);
    }

    // Contr√¥les clavier
    function onKeyDown(event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
        case 'KeyZ': // AZERTY
          moveForward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
        case 'KeyQ': // AZERTY
          moveLeft = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = true;
          break;
        case 'Space':
          if (canJump === true) velocity.y += 350;
          canJump = false;
          break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
        case 'KeyZ': // AZERTY
          moveForward = false;
          break;
        case 'ArrowLeft':
        case 'KeyA':
        case 'KeyQ': // AZERTY
          moveLeft = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = false;
          break;
      }
    }

    // Contr√¥les manette
    function updateGamepads() {
      const gamepadList = navigator.getGamepads ? navigator.getGamepads() : [];
      
      for (let i = 0; i < gamepadList.length; i++) {
        const gamepad = gamepadList[i];
        if (!gamepad) continue;
        
        gamepads[gamepad.index] = gamepad;
        
        // Stick gauche - D√©placement
        const leftStick = readStickAxes(gamepad.axes.slice(0, 2));
        const rightStick = readStickAxes(gamepad.axes.slice(2, 4));
        
        // D√©placement avec stick gauche
        if (Math.hypot(leftStick.x, leftStick.y) > 0.1) {
          moveForward = leftStick.y < -0.1;
          moveBackward = leftStick.y > 0.1;
          moveLeft = leftStick.x < -0.1;
          moveRight = leftStick.x > 0.1;
        } else {
          // R√©initialiser si stick inactif
          if (!isKeyPressed()) {
            moveForward = moveBackward = moveLeft = moveRight = false;
          }
        }
        
        // Stick droit - Rotation
        if (Math.abs(rightStick.x) > 0.1) {
          rig.rotation.y -= rightStick.x * 0.05 * turnSpeed;
        }
        
        if (Math.abs(rightStick.y) > 0.1 && !controls.isLocked) {
          // Pitch seulement si les contr√¥les souris ne sont pas actifs
          pitchObject.rotation.x = THREE.MathUtils.clamp(
            pitchObject.rotation.x + rightStick.y * 0.05 * turnSpeed, 
            -Math.PI/3, 
            Math.PI/3
          );
        }
      }
    }
    
    function readStickAxes(axes) {
      return { x: axes[0] || 0, y: axes[1] || 0 };
    }
    
    function isKeyPressed() {
      return moveForward || moveBackward || moveLeft || moveRight;
    }

    // Mouvement
    function updateMovement(delta) {
      // Vitesse de d√©placement relative au temps
      const actualMoveSpeed = moveSpeed * delta;
      
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();

      if (moveForward || moveBackward) velocity.z -= direction.z * actualMoveSpeed;
      if (moveLeft || moveRight) velocity.x -= direction.x * actualMoveSpeed;

      // Appliquer le mouvement dans la direction du regard (yaw seulement)
      const yaw = rig.rotation.y;
      const moveX = velocity.x * Math.cos(yaw) - velocity.z * Math.sin(yaw);
      const moveZ = velocity.x * Math.sin(yaw) + velocity.z * Math.cos(yaw);
      
      rig.position.x += moveX * delta;
      rig.position.z += moveZ * delta;
      
      // Garder le joueur au sol
      if (rig.position.y < 1.6) {
        velocity.y = 0;
        rig.position.y = 1.6;
        canJump = true;
      }
    }

    // Animation
    function animate() {
      requestAnimationFrame(animate);
      
      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      
      // Mettre √† jour les manettes
      updateGamepads();
      
      // Mettre √† jour le mouvement
      if (controls.isLocked) {
        updateMovement(delta);
      }
      
      // Rendu
      renderer.render(scene, camera);
      prevTime = time;
    }

    // Redimensionnement
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // D√©marrer
    init();
    animate();
  </script>
</body>
</html>