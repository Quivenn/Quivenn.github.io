<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>SceneVR – Exercice 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://aframe.io/releases/0.9.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@v4.0.1/dist/aframe-physics-system.min.js"></script>
  <style>
    html,body{margin:0;height:100%}
    a-scene{position:fixed;inset:0}
    .hud{position:fixed;left:12px;top:12px;padding:8px 12px;background:#0008;color:#fff;border-radius:8px;font-family:system-ui}
    .hud-bottom{position:fixed;left:12px;bottom:12px;padding:8px 12px;background:#0008;color:#fff;border-radius:8px;font-family:system-ui}
    .grab-line {position: absolute; background: #00f; height: 2px; transform-origin: 0 0;}
  </style>
</head>
<body>
  <div class="hud">🎮 Gauche: déplacer — Droite: tourner (desktop: stick droit = yaw + pitch)</div>
  <div class="hud-bottom">🎯 Bouton grip pour saisir/relâcher les objets</div>

  <a-scene
    renderer="antialias:true; physicallyCorrectLights:true; colorManagement:true; logarithmicDepthBuffer:true; sortTransparentObjects:true"
    shadow="type: pcfsoft"
    physics="driver: cannon; debug: false">

    <!-- Sol -->
    <a-entity id="ground" static-body geometry="primitive:plane;width:40;height:40"
              rotation="-90 0 0" material="color:#7da07d;roughness:1;metalness:0"
              shadow="receive:true"></a-entity>

    <!-- Objets -->
    <a-box class="grabbable" position="-1 0.5 -3" depth="1" height="1" width="1" dynamic-body
           material="color:#c94f4f;roughness:0.8;metalness:0.2"
           shadow="cast:true;receive:true"></a-box>
    <a-sphere class="grabbable" position="1 1 -2.5" radius="1" dynamic-body
              material="color:#4f79c9;roughness:0.6;metalness:0.2"
              shadow="cast:true;receive:true"></a-sphere>

    <!-- Lumières -->
    <a-entity light="type:ambient;intensity:0.35;color:#fff"></a-entity>
    <a-entity id="sun"
              light="type:directional;intensity:1;castShadow:true;shadowBias:-0.0003"
              position="5 8 3" rotation="-45 30 0"></a-entity>

    <a-sky src="panorama_image.png" rotation="0 -90 0"></a-sky>

    <!-- Rig + caméra + contrôleurs -->
    <a-entity id="rig" position="0 1.6 5" rotation="0 0 0" wasd-controls="acceleration:20">
      <a-entity id="pitch" rotation="0 0 0">
        <a-entity id="head" camera look-controls="pointerLockEnabled: true"></a-entity>
      </a-entity>

      <!-- Contrôleurs avec composants de saisie -->
      <a-entity id="left" hand-controls="hand: left" left-stick-move="speed:3" 
                grab-controls="hand: left"></a-entity>
      <a-entity id="right" hand-controls="hand: right" right-stick-turn="turnSpeed:120; deadzone:0.08" 
                grab-controls="hand: right"></a-entity>
    </a-entity>

    <!-- WebXR -->
    <a-entity webxr="optionalFeatures: local-floor, bounded-floor"></a-entity>
  </a-scene>

  <script>
    function readStickAxes(axis){
      // Certains profils/émulateurs envoient les sticks sur [2,3]
      const ax = axis || [];
      let x = ax[0] ?? 0, y = ax[1] ?? 0;
      if (Math.abs(x) < 0.001 && Math.abs(y) < 0.001 && ax.length >= 4) {
        x = ax[2] ?? 0; y = ax[3] ?? 0;
      }
      return {x, y};
    }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // Joystick gauche = déplacement (g/d inversé corrigé)
    AFRAME.registerComponent('left-stick-move', {
      schema: { speed: {type:'number', default:3}, deadzone:{type:'number', default:0.05} },
      init() {
        this.axis = {x:0,y:0};
        this.rig  = document.querySelector('#rig');
        this.cam  = document.querySelector('#head');
        this.el.addEventListener('axismove', e => { this.axis = readStickAxes(e.detail.axis); });
      },
      tick(t,dt){
        if(!this.rig||!this.cam) return;
        const s = this.data.speed*(dt/1000);
        let {x,y} = this.axis;
        if (Math.hypot(x,y) < this.data.deadzone) return;

        const yaw=(this.rig.getAttribute('rotation')?.y||0)+(this.cam.getAttribute('rotation')?.y||0);
        const rad=THREE.MathUtils.degToRad(yaw);
        const forward=new THREE.Vector3(-Math.sin(rad),0,-Math.cos(rad));
        const right  =new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).negate();

        this.rig.object3D.position
          .addScaledVector(forward, -y*s)  // avancer/reculer (inverse si tu préfères)
          .addScaledVector(right,   -x*s); // gauche/droite (inversé corrigé)
      }
    });

    // Joystick droit = yaw (VR+desktop) + pitch (desktop seulement)
    AFRAME.registerComponent('right-stick-turn', {
      schema:{ turnSpeed:{type:'number',default:120}, deadzone:{type:'number',default:0.08} },
      init(){
        this.x=0; this.y=0;
        this.rig   = document.querySelector('#rig');
        this.pitch = document.querySelector('#pitch'); // ⬅️ on cible le pivot
        this.el.addEventListener('axismove', e => {
          const a = readStickAxes(e.detail.axis);
          this.x = a.x; this.y = a.y;
        });
      },
      tick(t,dt){
        if(!this.rig) return;
        const s = this.data.turnSpeed * (dt/1000);

        // Yaw (gauche/droite) – sens inversé (comme avant)
        let x=this.x;
        if (Math.abs(x) >= this.data.deadzone) {
          const rot=this.rig.getAttribute('rotation')||{x:0,y:0,z:0};
          rot.y -= Math.sign(x)*Math.pow(Math.abs(x),1.3)*s;
          this.rig.setAttribute('rotation', rot);
        }

        // Pitch (haut/bas) — en VR ET en desktop via le pivot
        if (this.pitch && Math.abs(this.y) >= this.data.deadzone) {
          const pr=this.pitch.getAttribute('rotation')||{x:0,y:0,z:0};
          pr.x = clamp(pr.x + (-this.y)*s, -80, 80); // -y = mapping naturel
          this.pitch.setAttribute('rotation', pr);
        }
      }
    });

    // Composant pour la saisie d'objets
    AFRAME.registerComponent('grab-controls', {
      schema: {
        hand: {type: 'string', default: 'right'},
        maxDistance: {type: 'number', default: 5}
      },
      init: function () {
        this.grabbedObject = null;
        this.raycaster = new THREE.Raycaster();
        this.direction = new THREE.Vector3();
        this.origin = new THREE.Vector3();
        this.lineElement = null;
        this.isGripping = false;
        
        // Créer une ligne de visée
        this.createLine();
        
        // Écouter les événements des boutons
        this.el.addEventListener('gripdown', this.onGripDown.bind(this));
        this.el.addEventListener('gripup', this.onGripUp.bind(this));
      },
      
      createLine: function() {
        // Créer une entité pour la ligne de visée
        const line = document.createElement('a-entity');
        line.setAttribute('class', 'grab-line');
        line.setAttribute('line', {
          color: '#00F',
          opacity: 0.5,
          visible: false
        });
        this.el.appendChild(line);
        this.lineElement = line;
      },
      
      updateLine: function() {
        if (!this.lineElement) return;
        
        const handPosition = new THREE.Vector3();
        this.el.object3D.getWorldPosition(handPosition);
        
        this.direction.set(0, 0, -1);
        this.el.object3D.localToWorld(this.direction);
        this.direction.sub(handPosition).normalize();
        
        this.raycaster.set(handPosition, this.direction);
        
        const intersects = this.raycaster.intersectObjects(
          document.querySelectorAll('.grabbable').map(el => el.object3D), 
          true
        );
        
        // Afficher/masquer la ligne selon si on vise un objet
        const hasIntersection = intersects.length > 0 && intersects[0].distance <= this.data.maxDistance;
        this.lineElement.setAttribute('line', {
          start: {x: 0, y: 0, z: 0},
          end: {x: 0, y: 0, z: hasIntersection ? -intersects[0].distance : -this.data.maxDistance},
          color: hasIntersection ? '#0F0' : '#00F',
          opacity: 0.8,
          visible: true
        });
      },
      
      onGripDown: function() {
        if (this.grabbedObject) return;
        
        const handPosition = new THREE.Vector3();
        this.el.object3D.getWorldPosition(handPosition);
        
        this.direction.set(0, 0, -1);
        this.el.object3D.localToWorld(this.direction);
        this.direction.sub(handPosition).normalize();
        
        this.raycaster.set(handPosition, this.direction);
        
        const intersects = this.raycaster.intersectObjects(
          document.querySelectorAll('.grabbable').map(el => el.object3D), 
          true
        );
        
        if (intersects.length > 0 && intersects[0].distance <= this.data.maxDistance) {
          const object = intersects[0].object;
          let entity = object.el;
          
          // Remonter jusqu'à l'entité A-Frame
          while (entity && !entity.hasAttribute('class') && entity.parentEl) {
            entity = entity.parentEl;
          }
          
          if (entity && entity.classList.contains('grabbable')) {
            this.grabObject(entity);
          }
        }
      },
      
      onGripUp: function() {
        if (this.grabbedObject) {
          this.releaseObject();
        }
      },
      
      grabObject: function(object) {
        this.grabbedObject = object;
        
        // Désactiver la physique temporairement
        if (object.body) {
          object.body.sleep();
          object.body.type = CANNON.Body.KINEMATIC;
          object.setAttribute('dynamic-body', 'mass', 0);
        }
        
        // Attacher l'objet au contrôleur
        this.el.appendChild(object);
        
        // Positionner l'objet devant le contrôleur
        object.setAttribute('position', {x: 0, y: 0, z: -0.5});
      },
      
      releaseObject: function() {
        if (!this.grabbedObject) return;
        
        // Détacher l'objet du contrôleur
        this.el.removeChild(this.grabbedObject);
        
        // Remettre l'objet dans la scène
        document.querySelector('a-scene').appendChild(this.grabbedObject);
        
        // Réactiver la physique
        if (this.grabbedObject.body) {
          this.grabbedObject.body.type = CANNON.Body.DYNAMIC;
          this.grabbedObject.body.wakeUp();
          this.grabbedObject.setAttribute('dynamic-body', 'mass', 2);
          
          // Appliquer une petite vitesse pour un lancer plus naturel
          const velocity = new THREE.Vector3(0, 0, -2);
          this.el.object3D.localToWorld(velocity);
          this.grabbedObject.body.velocity.set(velocity.x, velocity.y, velocity.z);
        }
        
        this.grabbedObject = null;
      },
      
      tick: function() {
        if (!this.grabbedObject) {
          this.updateLine();
        } else {
          // Masquer la ligne quand on tient un objet
          this.lineElement.setAttribute('line', 'visible', false);
        }
      }
    });

    document.querySelector('a-scene').addEventListener('loaded', () => {
      ['left','right'].forEach(id=>{
        const el=document.getElementById(id);
        el.addEventListener('axismove', e=>console.log(id,'axes',e.detail.axis));
        el.addEventListener('buttonchanged', e=>console.log(id,'button',e.detail));
      });
    });
  </script>
</body>
</html>